
# Spaces

coordinate systems: [w/Coordinate_vector] [w/Basis_(linear_algebra)]
  > in graphics, we are dealing with vector data describing some objects in a space
  > mathematically, we say that we have a vector space with some defined basis vectors (forming our axes)
    > e.g. in 3D graphics we have the x, y, and z basis vectors that span a 3-dimensional vector space
    > we assume that this space is Euclidian (although some non-Euclidian simulations/games also exist)
  > the overall scene (or "world") that is being rendered has a coordinate system called "world space"
    > all objects as well as the camera (1D point) and the screen (2D plane) are positioned in this world space
  > however, doing all calculations in world space becomes very inconvenient
    > e.g. it means that if we want to reorient a model, all of the previously known vertex coords become invalid
    > in addition, some systems like the rasterizer dictate their own coordinate systems that we must adapt to
  > thus, we work with several different "spaces" (coordinate systems/vector spaces), and transform between them
  > to transform from one space to another we use a *matrix transformation*, which can perform one of:
    - linear transformation (nxn-dimensional matrix for an n-dimensional space)
    - affine/projective transformation ((n+1)x(n+1)-dimensional matrix for an n-dimensional space)
    > see also the previous document on matrix transformations

hierarchical modeling:
  > ref: [g5min] https://www.youtube.com/watch?v=4iNJdWXsFQ4
  > taking the idea of separate spaces a step further, it is common to define *hierarchical models*
  > here, models (and the overall scene in general) is defined as a tree of models, each with its own local coordinates
  > when any model is transformed (changes coordinate system), all descendent models are transformed with it
  > implementation:
    > the transformation matrix for each model is stored on the edge in tree
    > when rendering the tree, a stack of matrices is maintained and each time we visit a child that matrix is pushed
    > the transformation matrix for a given node is the product of all the matrices currently on the stack

common spaces:
  - world space
    > the "global" coordinate system of the entire scene
    > characteristics:
      > the origin is at some arbitrary position, usually somewhere in the middle of the scene, but not necessarily
      > axes are again arbitrary, but usually x and y will define the "ground" plane, and +z extends upwards
  - local space (also called "model space", "object space")
    > a local coordinate system for a given object/model (see also hierarchical modeling above)
    > characteristics:
      > the origin is arbitrary, but will usually be in the center of the object
      > axes are similar to world space, usually x/y define the ground plane and +z is upwards (but not necessarily)
  - camera space (also called "eye space") [w/Virtual_camera_system]
    > the "(virtual) camera" represents the observer (this is closely related to the screen, but subtly different)
    > there are two ways to model the camera:
      - orthographic projection
      - perspective projection
    > in orthographic projection, the camera is a 2D bounded plane (rectangle) in space
      > all objects in the world are projected orthographically on this camera plane
      > in this case, there is no depth perception (in the sense of further objects being rendered smaller)
      > the "field of view" in this case is a cuboid that extends from the camera plane into infinity
      > the larger the camera plane, the more of space can be seen
    > in perspective projection, the camera (or "eye") is a 1D point in space
      > all objects in the world are projected using perspective projection onto this point
      > the *field of view* (FOV) is defined by an infinite pyramid extending from the camera into infinity
        > in real life this would be a cone, but in computer graphics we use a pyramid to match the rectangular screen
        > the FOV is parameterized by two components: the horizontal and vertical angle of view [w/Angle_of_view]
          > the ratio of these angles should generally match the viewport (screen) aspect ratio
      > characteristics:
        > the origin is always at the point of the camera
        > the +z axis extends from the camera through the middle of the FOV pyramid
        > the x and y axes extend horizontally and vertically, aligned with the cross section plane of the pyramid
  - clip space
    > https://gamedev.stackexchange.com/questions/29018/why-does-opengl-require-all-coordinates-in-1-1-ndc
    > clip space is the coordinate system of the rasterizer (e.g. OpenGL)
      > vertices returned from the vertex shader are defined in this space
      > it is called "clip space" because all vertices outside of the (-1, 1) volume (along x/y/z) are "clipped"
      > this (-1, 1) volume is then projected on the screen plane, which is the x/y plane at z = -1 bounded by (-1, 1)
      > finally, the screen is displayed on the viewport (display device) scaled by the viewport aspect ratio
    > in an orthographic projection, we can think of clip space as being a volume cut from the orthographic view space
      by two clip planes: the near and far clip planes
      > if we consider the camera at the origin, then we simply need to translate to the origin of the clip space
    > this is basically the same as "camera space", but the term clip space is specifically from the perspective
      of the rasterizer (which doesn't necessarily involve any "camera" or "eye" at all)
    > clip space is the space of vectors that the vertex shader provides to the rasterizer
    > the rasterizer will "clip" anything that is not within a (-1,1) range for both x, y, and z
    > see also: "Normalized Device Coordinates" (NDC)
  - screen space (or: "viewport space")
